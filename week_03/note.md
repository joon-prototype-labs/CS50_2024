### References

- https://cs50.harvard.edu/x/2024/notes/3/
- https://manual.cs50.io/
- https://cs50.readthedocs.io/style/c/

### Note

#### 알고리즘

- 문제를 해결하는 일련의 방식.
- 시간 복잡도애 데이터 크기에 따라서 완료하기까지 걸리는 시간을 결정하는 척도이다.
- 시간 복잡도 - 대충 설명
  - 상수나 낮은 지수를 무시하고, 가장 높은 지수를 기준으로 판단한다.
  - 표기법
    - O(빅오): 최악의 경우. 주로 요구사항은 상한선을 결정하므로, 이 표기법이 주로 쓰인다. 
    - Ω(오메가): 최선의 경우
    - Θ(세타): 평균적인 성능, 주로 상항과 하한이 일치할 때 사용한다.

#### 검색
- 선형 검색
  - 한 끝에서 다른 쪽 끝까지 탐색하는 방식
  - O(1)이다.
- 이진 검색
  - 정렬된 상태일 때, 중간에서부터 찾는 수에 가까운 값을 제외한 다른 쪽 절반을 버리는 식으로 찾는 방법.
  - O(nlogn)이다.

#### C 구조체
- `struct`를 사용해서 다른 타입의 요소를 하나로 관리할 수 있다.
  - (이거 메모리 저장되는 법 관련해서 좀 복잡했던거 같은데 기억이 안남)

#### 정렬

더 많긴 한데, 강의에서 다루는거만

설명을 대충하는거라, 정렬 기준, 구체적인 구현 방법은 스킵.

- O(n^2)
  - 선택 정렬: 1부터 맞는 값을 찾고 요소에 넣기를 반복, 요소의 끝까지 반복을 수행한다. 최선의 경우에도 n^2   
  - 버블 정렬: i와 i+1을 비교하면서 i가 더 큰 경우 swap을 반복, 요소의 길이 N - 1 까지 반복한다. (배열의 경우 인덱스라 N-2)
- O(nlogn)
  - 병합 정렬: 중요한거라 아래서 구체적으로 설명

#### 병합(Merge) 정렬 - 중요해서 따로

이거는 개인적으로 이해 못핸던 부분을 알게되서, 강의 내용이랑은 무관한게 많음.

- 배경
  - 일반적으로 알고리즘의 시간 복잡도는 O(n^2)를 갖는 경우가 많아 보이는데, 머지 정렬(다른 정렬도)은 어떻게 더 효율적인지 이해를 못했음.
  - 둘 다 그리 복잡한 알고리즘은 아닌데, 어떤 차이가 있는지 이해를 못함.
  - 강의에서 문제를 "분할하는 것을 통해서 로그 복잡도로 수행할 수 있다."라는 식의 이야기를 했는데, 이걸 통해서 이해함.

- 머지 정렬의 핵심은 문제를 "분할"함으로써 복잡도를 줄이는 것.
  - 문제를 절반씩 나누는 과정에서 (logn)의 복잡도가 발생함.

- 수행 순서
  - 문제를 logN 번의 분할 과정으로 나누고,
  - 각 분할 단계에서 N번의 병합 과정을 거쳐,
  - 총 시간 복잡도 O(nlogn)을 가진다.

- 병합 과정을 구체적으로
  - 역할: 두개의 분할된 하위 배열을 하나의 배열로 합치는 과정
  - 알고리즘:
    - 배열의 요소가 하나인 경우, 이미 정렬되었으므로 리턴(base case)
    - 두 하위 배열이 구한 경우,
      - 두 배열의 앞에 위치한 요소를 비교하고, 작은 값을 새 배열로 옮기는 것을 반복한다.
        - 비교 O(1), 옮기기 O(1), 하위 요소 2개의 합만큼 반복 O(N)
    - 최종적으로, 하나의 정렬된 배열이 완성된다.

- **분할 정복의 중요성**
  - 문제를 분할하고 병합하는 것으로 연산의 횟수를 줄일 수 있다.
    - 항상 시간 복잡도가 낮아지는 건 아니지만, 시간 복잡도가 낮아지는 것도 가능함.
    - 아래 트럼프 카드의 예시만 봐도, 시간 복잡도는 그대로더라도, 전체 연산의 수를 확 줄일 수 있다.
- 나(사람)은 실제 생활에서도 비슷한 원리를 무의식적으로 적용하고 있음
  - 친구들과 브루마블 게임을 하고 정리할 떄, 물체를 그룹별(건물, 플레이어, 카드 종류 등)로 나누는 방식.
  - 트럼프 카드를 기호별로 먼저 정리하고, 그 후에 순서대로 정렬하는 방식.
    - 그럼 기호 별로 4개로 나뉘어졌으므로, 전체 크기가 작아졌으므로 (분할 없이 수행하는 것 대비) 더 효율적이다.
    - 분할 없이는 52장, 분할 있이는 13장씩 처리하면 된다.
      - 정렬이 N^2라고 가정하면, `52^2 = 2704`, `13^2 * 4 = 676`로 분할하는게 더 효율적임.

- 그러나 기계는 직관이 없음
  - 사람과 달리 기계는 직관적으로 문제를 분할하지 않기 때문에, 프로그래머가 직접 문제를 분할(=기억)하도록 알고리즘을 설계해야 함.
  - 분할 후에는 그 상태를 기억하기 위한 추가 메모리 사용이 필요하며, 이는 속도와 메모리 사이의 trade-off를 의미함.
    - Dynamic Programming도 마찬가지.

#### 재귀

- 본인을 호출하는 함수.
- base case과 recursive relation을 가져야한다. (base case가 없으면 컴파일러 에러가 나기도)
- 모든 재귀는 반복문으로 구현될 수 있고, 그 반대도 마찬가지이다. 본질적으로 같기 떄문.

### 리뷰

- 이번에 머지 정렬을 이해함. 
  - 정렬을 제대로 공부한적이 없었다. 코테 공부할 떄도 알아서 해주니까 넘어갔었고...
  - 갑자기 강사분 말 듣고, 이해함.
    - 대부분 저런 순간이 퍼즐 풀리는거처럼 팍 깨닫게 되는데, 이떄 쾌감이 막 생긴다.

- 자연스럽게 진행되서 의식을 못했는데
  - 내가 C언어 자체에 대한 것보다 강의에 - 정확히는 강의에서 이야기하는 문제 해결 - 더 집중하고 있었다.
  - 물론 C언어를 좀 알아서 그런걸수도 있는데, 강의에서 다룬 부분이 많지 않다는걸 생각해보면
    - 의도적으로 C언어(or 프로그래밍)에 대한 설명을 줄이고 문제 해결에 더 집중하고 있는데, 이게 오히려 CS 적인 이해, 사고를 알려주는데는 좋다고 느낌.

- 그리고 강의하는 [교수](https://en.wikipedia.org/wiki/David_J._Malan)(David J. Malan)가 되게 열정적이다.
  - 강의하는거 볼떄마다 땀 뻘뻘흘리고 있음.  
